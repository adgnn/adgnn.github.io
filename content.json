[{"title":"计算机组成原理-存储器设计实验","date":"2019-05-03T09:49:01.998Z","path":"2019/05/03/2019-5-3-计算机组成原理-存储器设计实验/","text":"实验目的：掌握灵活运用Verilog HDL语言进行各种描述与建模的技巧和方法；学习在Vivado中使用Memory IP核生成存储器的方法；学习存储器的结构及读写原理，掌握存储器的设计方法。 实验要求：实验vivado内置的IP核生成一个存储器，并写一个顶层模块验证。 验证模块：123456789101112131415161718192021222324252627282930313233343536module ram(out,Write_Addr_swb,sw,Clk_swb,Write_swb);input [32:1]sw;input Write_Addr_swb; //写地址按钮input Clk_swb=0; //时钟引脚input Write_swb=0; //写信号引脚output reg[32:1] out;reg [6:1] Mem_Addr; //6个逻辑开关 当按钮1按下，32位开关中6位是读写存储器的地址reg [32:1] W_Data; //32个逻辑开关 写操作时，当按钮2按下时，32位开关值是写入数据wire [32:1] R_Data;reg Mem_Write; //1个按钮 =1为写操作 =0为读操作reg clka; //时钟RAM_B Data_RAM ( .clka(clka), // input wire clka .wea(Mem_Write), // input wire [0 : 0] wea .addra(Mem_Addr[6:1]), // input wire [5 : 0] addra .dina(W_Data), // input wire [31 : 0] dina .douta(R_Data) // output wire [31 : 0] douta);always @(*) begin clka&lt;=Clk_swb; //时钟 Mem_Write&lt;=Write_swb; //写地址信号 if(Write_Addr_swb) //写地址地址 Mem_Addr&lt;=sw[6:1]; if(!Mem_Write &amp; clka) //读存储器 out&lt;=R_Data; else if(Mem_Write &amp; clka) //写存储器 W_Data&lt;=sw; endendmodule 仿真文件：123456789101112131415161718192021222324252627282930313233343536module ram(out,Write_Addr_swb,sw,Clk_swb,Write_swb);input [32:1]sw;input Write_Addr_swb; //写地址按钮input Clk_swb=0; //时钟引脚input Write_swb=0; //写信号引脚output reg[32:1] out;reg [6:1] Mem_Addr; //6个逻辑开关 当按钮1按下，32位开关中6位是读写存储器的地址reg [32:1] W_Data; //32个逻辑开关 写操作时，当按钮2按下时，32位开关值是写入数据wire [32:1] R_Data;reg Mem_Write; //1个按钮 =1为写操作 =0为读操作reg clka; //时钟RAM_B Data_RAM ( .clka(clka), // input wire clka .wea(Mem_Write), // input wire [0 : 0] wea .addra(Mem_Addr[6:1]), // input wire [5 : 0] addra .dina(W_Data), // input wire [31 : 0] dina .douta(R_Data) // output wire [31 : 0] douta);always @(*) begin clka&lt;=Clk_swb; //时钟 Mem_Write&lt;=Write_swb; //写地址信号 if(Write_Addr_swb) //写地址地址 Mem_Addr&lt;=sw[6:1]; if(!Mem_Write &amp; clka) //读存储器 out&lt;=R_Data; else if(Mem_Write &amp; clka) //写存储器 W_Data&lt;=sw; endendmodule 实验收获：Vivado中IP核的生成和调用方法。更熟练地掌握了仿真调试的方法。在仿真中，使用for语句对16个存储器地址写入，然后读出，很好地验证了预期结果","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://adgnn.github.io/tags/计算机组成原理/"},{"name":"verilog","slug":"verilog","permalink":"https://adgnn.github.io/tags/verilog/"},{"name":"vivado","slug":"vivado","permalink":"https://adgnn.github.io/tags/vivado/"},{"name":"FPGA","slug":"FPGA","permalink":"https://adgnn.github.io/tags/FPGA/"}]},{"title":"计算机组成原理-寄存器堆设计实验","date":"2019-05-03T09:49:01.996Z","path":"2019/05/03/2019-5-3-计算机组成原理-寄存器堆设计实验/","text":"实验目的： 学习使用Verilog HDL语言进行时序电路的设计方法 掌握灵活运用Verilog HDL语言进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读写工作原理，掌握寄存器堆的设计方法。 实验要求： 设计一个32*32位的寄存器堆（即含有32个寄存器，每个寄存器32位） 读访问操作：无需时钟同步，只要给出寄存器地址，即可读出寄存器中的数据。 写访问操作：需要时钟同步，所有写入操作的输入信号必须在时钟边沿来临时，已经有效（Write_Reg=1、地址和数据）。 寄存器模块：123456789101112131415161718192021222324252627282930module RegFile(Clk,Clr,Write_Reg,R_Addr_A, R_Addr_B,W_Addr,W_Data,R_Data_A,R_Data_B); input Clk; //时钟信号 input Clr; //清零信号 input Write_Reg; //写控制信号 input [5:1]R_Addr_A; //A端口读寄存器地址 input [5:1]R_Addr_B; //B端口读寄存器地址 input [5:1]W_Addr; //写寄存器地址 input [32:1]W_Data; //写入数据 output [32:1]R_Data_A; //A端口读出数据 output [32:1]R_Data_B; //B端口读出数据 reg [32:1]Reg_Files[31:0]; //寄存器堆 integer i; //遍历 initial for(i=1;i&lt;=32;i=i+1) Reg_Files[i]&lt;=0; always@(posedge Clk or posedge Clr) begin if(Clr)//检测清零 for(i=1;i&lt;=32;i=i+1) Reg_Files[i]&lt;=0; else //检测写控制，高电平则写入寄存器 if(Write_Reg) Reg_Files[W_Addr]&lt;=W_Data; end assign R_Data_A=Reg_Files[R_Addr_A]; assign R_Data_B=Reg_Files[R_Addr_B];endmodule 顶层验证模块：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module registers(sw,button,out); input [32:1] sw; input [6:1] button; output reg[32:1] out=32'hzzzz_zzzz; reg Clk=1'b0; reg Clr=1'b0; reg Write_Reg=1'b0; reg [5:1] R_Addr_A=5'bz; reg [5:1] R_Addr_B=5'bz; reg [5:1] W_Addr=5'bz; reg [32:1] W_Data=32'bz; reg [32:1] Reg_Files[31:0]; wire [32:1] R_Data_A; wire [32:1] R_Data_B; RegFile RF( .Clk(Clk), .Clr(Clr), .Write_Reg(Write_Reg), .R_Addr_A(sw[32:28]), .R_Addr_B(sw[27:23]), .W_Addr(W_Addr), .W_Data(W_Data), .R_Data_A(R_Data_A), .R_Data_B(R_Data_B)); always @(*) begin case(button) 6'b100000: begin W_Addr&lt;=sw[5:1]; end //输入低5位为寄存器地址 6'b010000: begin W_Data&lt;=sw; end //输入寄存器内容 6'b001000: begin Write_Reg&lt;=sw[1]; end//提供Write_Reg信号，=1写操作 6'b000100: begin Clr&lt;=button[3]; end //提供Reset 6'b000010: begin if(sw[1]) out&lt;=R_Data_A; else out&lt;=R_Data_B; end //读A/B端口选择 6'b000000: begin out&lt;=32'bz; Clr&lt;=0; Clk&lt;=0; end 6'b000001: begin Clk&lt;=button[1]; end //提供Clk信号 default: begin out&lt;=32'bz; Clr&lt;=0; Clk&lt;=0; end endcase endendmodule 仿真文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module registers(sw,button,out); input [32:1] sw; input [6:1] button; output reg[32:1] out=32'hzzzz_zzzz; reg Clk=1'b0; reg Clr=1'b0; reg Write_Reg=1'b0; reg [5:1] R_Addr_A=5'bz; reg [5:1] R_Addr_B=5'bz; reg [5:1] W_Addr=5'bz; reg [32:1] W_Data=32'bz; reg [32:1] Reg_Files[31:0]; wire [32:1] R_Data_A; wire [32:1] R_Data_B; RegFile RF( .Clk(Clk), .Clr(Clr), .Write_Reg(Write_Reg), .R_Addr_A(sw[32:28]), .R_Addr_B(sw[27:23]), .W_Addr(W_Addr), .W_Data(W_Data), .R_Data_A(R_Data_A), .R_Data_B(R_Data_B)); always @(*) begin case(button) 6'b100000: begin W_Addr&lt;=sw[5:1]; end //输入低5位为寄存器地址 6'b010000: begin W_Data&lt;=sw; end //输入寄存器内容 6'b001000: begin Write_Reg&lt;=sw[1]; end//提供Write_Reg信号，=1写操作 6'b000100: begin Clr&lt;=button[3]; end //提供Reset 6'b000010: begin if(sw[1]) out&lt;=R_Data_A; else out&lt;=R_Data_B; end //读A/B端口选择 6'b000000: begin out&lt;=32'bz; Clr&lt;=0; Clk&lt;=0; end 6'b000001: begin Clk&lt;=button[1]; end //提供Clk信号 default: begin out&lt;=32'bz; Clr&lt;=0; Clk&lt;=0; end endcase endendmodule 实验收获：寄存器堆设计和之前的ALU设计有一定的相似之处，如都是顶层+本体的设计方法，顶层控制着外部的输入输出，并将值传递到本体模块进行具体计算。 具体代码实现过程中，利用always语句块和assign语句来区分时序和非时序逻辑电路（写和读）。仿真过程遇到了点问题，最后一步本意为输出B读端口（ffff_ffff），结果输出为0，但上板后没有问题。","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://adgnn.github.io/tags/计算机组成原理/"},{"name":"verilog","slug":"verilog","permalink":"https://adgnn.github.io/tags/verilog/"},{"name":"vivado","slug":"vivado","permalink":"https://adgnn.github.io/tags/vivado/"},{"name":"FPGA","slug":"FPGA","permalink":"https://adgnn.github.io/tags/FPGA/"}]},{"title":"计算机组成原理-多功能ALU设计","date":"2019-05-03T09:49:01.994Z","path":"2019/05/03/2019-5-3-计算机组成原理-多功能ALU设计/","text":"实验目的： 学习多功能ALU的工作原理，掌握运算器的设计方法。 掌握运用Verilog HDL语言进行行为描述与建模的技巧和方法。 实验要求： 设计一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果为零标志ZF，溢出标志OF。 编写顶层模块，用于验证模块的正确性。 ALU模块：12345678910111213141516171819202122232425262728293031module ALU1(A,B,F,ALU_OP,OF,ZF); input [32:1] A; input [32:1] B; input [4:1] ALU_OP; output reg [32:1] F; output reg ZF,OF; reg C; always @(*) begin case(ALU_OP) 4'b0: begin F&lt;=A&amp;B; OF&lt;=0; end 4'b1: begin F&lt;=A|B; OF&lt;=0; end 4'b10:begin F&lt;=A^B; OF&lt;=0; end 4'b11:begin F&lt;=~(A|B); OF&lt;=0; end 4'b100:begin &#123;C,F&#125;&lt;=A+B; OF&lt;=C; end 4'b101:begin &#123;C,F&#125;&lt;=A-B; OF&lt;=C; end 4'b110:begin if(A&lt;B) F&lt;=1; else F&lt;=0; end 4'b111:begin F&lt;=B&lt;&lt;A; OF&lt;=1; end default:begin F&lt;=32'hzzzz_zzzz; OF&lt;=1'bz; end endcase if(F==0) ZF&lt;=1; else ZF&lt;=0; endendmodule 顶层验证模块：12345678910111213141516171819202122232425262728293031module ALU1(A,B,F,ALU_OP,OF,ZF); input [32:1] A; input [32:1] B; input [4:1] ALU_OP; output reg [32:1] F; output reg ZF,OF; reg C; always @(*) begin case(ALU_OP) 4'b0: begin F&lt;=A&amp;B; OF&lt;=0; end 4'b1: begin F&lt;=A|B; OF&lt;=0; end 4'b10:begin F&lt;=A^B; OF&lt;=0; end 4'b11:begin F&lt;=~(A|B); OF&lt;=0; end 4'b100:begin &#123;C,F&#125;&lt;=A+B; OF&lt;=C; end 4'b101:begin &#123;C,F&#125;&lt;=A-B; OF&lt;=C; end 4'b110:begin if(A&lt;B) F&lt;=1; else F&lt;=0; end 4'b111:begin F&lt;=B&lt;&lt;A; OF&lt;=1; end default:begin F&lt;=32'hzzzz_zzzz; OF&lt;=1'bz; end endcase if(F==0) ZF&lt;=1; else ZF&lt;=0; endendmodule 仿真文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283`timescale 1ns / 1psmodule test; reg [32:1] sw; reg [6:1] button; wire [32:1] out; alu uut( .sw(sw), .button(button), .out(out) ); initial begin sw = 0; button = 0; #100; //input A sw = 32'h1234_5678; button = 6'b100000; #50; //input B sw = 32'h1111_2222; button = 6'b010000; #50; //and sw[4:1] = 4'h0; button = 6'b001000; #50; button = 6'b0; #50; //or sw[4:1] = 4'h1; button = 6'b001000; #50; button = 6'b0; #50; //xor sw[4:1] = 4'h2; button = 6'b001000; #50; button = 6'b0; #50; //nor sw[4:1] = 4'h3; button = 6'b001000; #50; button = 6'b0; #50; //add sw[4:1] = 4'h4; button = 6'b001000; #50; button = 6'b0; #50; //sub sw[4:1] = 4'h5; button=6'b001000; #50; button = 6'b0; #50; //slt sw[4:1] = 4'h6; button = 6'b001000; #50; button = 6'b0; #50; //sll sw[4:1] = 4'h7; button = 6'b001000; #50; button = 6'b0; #50; endendmodule 实验收获：实验过程中，我发现自己对Verilog HDL语言的熟悉程度不够。特别是对阻塞赋值与非阻塞赋值的思想没有理解透彻，导致程序在调试过程中不断出现BUG，难以表达应有的逻辑思想。编程没有充分体现电路本身的特征，仍然是用C语言等高级程序设计语言的思想来编程。 总体来说，本实验较为基础，不困难。","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://adgnn.github.io/tags/计算机组成原理/"},{"name":"verilog","slug":"verilog","permalink":"https://adgnn.github.io/tags/verilog/"},{"name":"vivado","slug":"vivado","permalink":"https://adgnn.github.io/tags/vivado/"},{"name":"FPGA","slug":"FPGA","permalink":"https://adgnn.github.io/tags/FPGA/"}]}]