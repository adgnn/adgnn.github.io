[{"title":"WIN下从零搭建个人博客","date":"2019-05-04T10:51:01.055Z","path":"2019/05/04/2019-5-3-WIN下从零搭建个人博客/","text":"1. 前言耗时两天搭建了一个个人博客：adgnn的个人博客 本博客是搭建在github page上的，没有购买个人域名，所以不需要花钱就可以搭建一个属于自己的博客。 本博客仅说明WINDOWS环境下的博客搭建 2. 准备 - 需要下载的工具Git （官网点击Download即可下载，安装完后就可以使用Git Bash命令行工具进行操作。） NodeJS (LTS栏里点击Windows即可下载) VPN（最好在能够访问外网的情况下安装，可忽略） notepad++（更好的文本/代码编辑软件，可忽略） 3. 安装hexo 在某个地方创建一个文件夹（如G:\\myblog\\）（名字随意） 右键这个文件夹，选择Git Bash Here 在打开的命令行窗口内输入命令安装hexo 1npm i -g hexo-cli 初始化hexo于myblog文件夹 1hexo init myblog自己想取什么名字都行 安装 1npm i 4. Github创建个人仓库网站链接：Github 注册Github帐号（记住你的用户名和注册用的邮箱，之后要用） 登录 点击New repository 创建一个和自己用户名相同的仓库，即用户名.github.io （如本人用户名是adgnn，则创建名为adgnn.github.io的仓库） 点Create repository 5. 生成SSH并添加到Github SSH是你电脑Git和Github连接的钥匙，请按如下步骤配置。 回到Git Bash窗口，输入代码表示你的用户名和注册邮箱 12git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot; 双引号””中的yourname替换成你的用户名 双引号””中的youremail替换成你的注册邮箱 创建SSH 1ssh-keygen -t rsa -C &quot;youremail&quot; 双引号””中的youremail替换成你的注册邮箱 之后弹出的信息不需要输入任何东西，一直回车直到命令执行完毕。 执行完毕后，在命令行窗口里找到.ssh的文件夹，打开“此电脑”（或资源管理器），输入这个地址，回车 用记事本打开id_rsa.pub备用 打开Github网页，点右上角自己的头像—settings—找到SSH设置选项，点击New SSH Key，把你的id_rsa.pub的信息复制进去 在Git Bash检查是否成功 1ssh -T git@github.com 6. 安装主题文件 本人的博客使用的主题是Yilia，简洁清新，功能实用。本篇以Yilia的安装为例。 Git Bash输入 1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 这个命令的功能是将github上的yilia项目clone（克隆）到你的themes目录下面 如果你觉得Git Bash的下载太慢，可以点这里 打开项目页面, 点击Clone or download ，Download ZIP，将下载好的ZIP文件里的hexo-theme-yilia-master文件夹解压到\\myblog\\themes\\下，并改名为yilia。 7. 配置_config.yml 安装好主题文件后，我们的myblog目录下一共会有两个_config.yml 一个在\\myblog\\下，另一个在\\myblog\\themes\\yilia\\下 为了避免混淆，将前者称为全局配置文件，后者称为主题配置文件。 我们绝大部分自定义内容都是在_config.yml里修改的。 用记事本分别打开全局配置文件和主题配置文件 下面是我的全局配置文件，请参考我的配置文件对自己的配置文件修改。（可参考官方说明）（请将所有和本作者有关的内容照例改成自己的） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: adgnn的个人博客subtitle: description: adgnn的个人博客keywords: blog, 博客author: adgnnlanguage: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://adgnn.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :year-:month-:day-:title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: truerelative_link: falsefuture: truehighlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/plugin:- hexo-generator-feed- hexo-generator-json-content#Feed Atomfeed: type: atom path: atom.xml limit: 20## Themes: https://hexo.io/themes/theme: yilia# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/adgnn/adgnn.github.io.git branch: master# JsonContentjsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 下面是我的主题配置文件，请参考并修改自己的配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131# Headermenu: 主页: / 归档: /archives/index.html# Blogger: https://adgnn.github.io# SubNavsubnav: github: \"https://github.com/adgnn\" #weibo: \"#\" rss: \"/atom.xml\" #zhihu: \"#\" #qq: \"#\" #weixin: \"#\" #jianshu: \"#\" #douban: \"#\" #segmentfault: \"#\" #bilibili: \"#\" #acfun: \"#\" #mail: \"mailto:litten225@qq.com\" #facebook: \"#\" #google: \"#\" #twitter: \"#\" #linkedin: \"#\"rss: /atom.xml# 是否需要修改 root 路径# 如果您的网站存放在子目录中，例如 http://yoursite.com/blog，# 请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。root: /# Content# 文章太长，截断按钮文字excerpt_link: more# 文章卡片右下角常驻链接，不需要请设置为falseshow_all_link: '展开全文'# 数学公式mathjax: true# 是否在新窗口打开链接open_in_new: false# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 0# 打赏wordingreward_wording: '谢谢你请我吃糖果'# 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpgalipay: # 微信二维码图片地址weixin: # 目录# 目录设定：0-不显示目录； 1-文章对应的md文件里有toc:true属性，才有目录； 2-所有文章均显示目录toc: 2# 根据自己的习惯来设置，如果你的目录标题习惯有标号，置为true即可隐藏hexo重复的序号；否则置为falsetoc_hide_index: true# 目录为空时的提示toc_empty_wording: '目录，不存在的…'# 是否有快速回到顶部的按钮top: true# Miscellaneousbaidu_analytics: '3224e7c6943d5a59748736b64c978518'google_analytics: ''favicon: #你的头像urlavatar: /img/portrait.jpg#是否开启分享share_jia: false#评论：1、多说；2、网易云跟帖；3、畅言；4、Disqus；5、Gitment#不需要使用某项，直接设置值为false，或注释掉#具体请参考wiki：https://github.com/litten/hexo-theme-yilia/wiki/#1、多说duoshuo: false#2、网易云跟帖wangyiyun: false#3、畅言changyan_appid: falsechangyan_conf: false#4、Disqus 在hexo根目录的config里也有disqus_shortname字段，优先使用yilia的disqus: false#5、Gitmentgitment_owner: false #你的 GitHub IDgitment_repo: '' #存储评论的 repogitment_oauth: client_id: '' #client ID client_secret: '' #client secret# 样式定制 - 一般不需要修改，除非有很强的定制欲望…style: # 头像上面的背景颜色 header: '#4d4d4d' # 右滑板块背景 slider: 'linear-gradient(200deg,#a0cfe4,#e8c37e)'# slider的设置slider: # 是否默认展开tags板块 showTags: true# 智能菜单# 如不需要，将该对应项置为false# 比如#smart_menu:# friends: falsesmart_menu: innerArchive: '所有文章' #friends: '友情链接' aboutme: '关于我'friends: # 友情链接1: http://localhost:4000/ # 友情链接2: http://localhost:4000/ # 友情链接3: http://localhost:4000/ # 友情链接4: http://localhost:4000/# 友情链接5: http://localhost:4000/# 友情链接6: http://localhost:4000/aboutme: 这里是adgnn的随手Blog 注意本文件里的baidu_analytics后面的数字是本人的百度分析代码，自己修改时请去掉或替换成自己的代码（参考本文末参考文章1） 8. 安装RSS、Sitemap、hexo-asset-image等插件123npm i hexo-asset-imagenpm i hexo-generator-feednpm i hexo-generator-sitemap RSS插件可让别人订阅你的Blog，详见本文档后面。 hexo-asset-image插件可以让你用![logo](logo.jpg)的方式插入图片。 9. 在本地查看自己的页面 在Git Bush输入 123hexo cleanhexo ghexo s 打开浏览器，地址栏输入 1localhost:4000 即可在浏览器预览自己的博客页面。 10. 将 hexo部署到Github 用记事本配置全局配置文件（_config.yml），该步已在第7步完成（请再次确认） 1234depoy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 注意：type、repo、branch前面要空2个空格，冒号: 后面要空1个空格 将YourgithubName替换成你的Github用户名。 在Git Bash安装deploy-git 1npm i hexo-deployer-git --save 部署到Github 123hexo cleanhexo ghexo d hexo clean：清除之前生成的缓存 hexo g：（generate）生成静态文章 hexo d：（deploy）部署文章 在执行hexo d的时候，第一次执行需要输入你的Github用户名和密码。 得到下图说明部署成功 部署成功后，等1分钟，就可以登录你的页面https://yourname.github.io查看了。 11. 写自己的文章 使用markdown编辑器（markdown请自行上网搜索了解，推荐Typora）编辑保存自己的文章。 保存命名为如下形式：20xx-x-x-标题.md，部署以后网站会自动读取日期和标题。 可在文件最前面加上yaml头部，如下格式： 12345---title: 从零搭建个人博客 #标题tags: [hexo, github] #标签toc: true #开启文章目录--- 将文件保存到\\myblog\\source\\_posts\\下 重新部署hexo到github上（第10-3步）（PS：每次更新都要重新部署） 最后的话本篇仅针对使用windows系统的小白，主要参考以下文章： hexo史上最全搭建教程 Hexo Blog搭建记录) 想要更深入了解请务必进入第1篇文章查看。 与本文相比，该文章还讲了：设置个人域名，yml参数含义，主题定制，RSS具体说明，github分支操作，coding page部署实现国内外分流，SEO优化，评论系统等","tags":[{"name":"github","slug":"github","permalink":"https://adgnn.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://adgnn.github.io/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"https://adgnn.github.io/tags/hexo/"}]},{"title":"羽毛球拍和线的选择","date":"2019-05-04T10:51:01.053Z","path":"2019/05/04/2019-5-4-羽毛球拍和线的选择/","text":"1. 重量 拍子重量是什么？ 一般全碳羽毛球拍重量标识为2u、3u、4u，数字越大，拍子重量越轻。 拍子重量对照表 2u：90-94g 3u：85-89g 4u：80-84g 5u：80g以下（超轻拍） 如何选择适合自己的拍子重量？ 较重的球拍适合力量较大的人，适合喜欢下压进攻的人群。较轻的球拍适合偏重防守、控球、力量较小的人。 男生建议3u,女生建议用4u. 2. 平衡点 什么是平衡点？ 平衡点指球拍横放时重心的位置（从球拍底部开始向上量）。若重心靠近拍柄（手抓的地方）即“头轻”，若重心更靠近拍头，叫“头重”。 头重：285mm-295mm。惯性大，杀球重，但挥拍灵活性差，不易发力，适用于进攻型球员。 头轻：275mm-285mm。挥拍灵活，但打出的球力量较小，杀球威胁更小，适合防守控制型球员。 平衡点和重量对手感的影响的区别？ 重量对挥拍的感觉成正比（1比1），平衡点对挥拍的感觉成平方正比。 简单来说，即重量每增加1个单位，挥拍的感觉就重1个单位；重量每增加2个单位，挥拍的感觉就重2个单位。 而平衡点每增长1个单位，挥拍的感觉重1个单位；平衡点每增长2个单位，挥拍的感觉就重4（$2^2$)个单位。 平衡点可以通过握拍位置以及手胶重量来调整，而拍身重量一般只通过手胶重量来调整。 3.拍线磅数 什么是拍线磅数？ 羽毛球拍磅数指拍头承受力大小，磅数越高，拍线越紧，拍面的弹性越小，击球需要的力量越大，但控制更精确。 磅数与击球感觉参考： 磅数范围 磅数 击球感觉 低磅 20磅以下 拍线松，拉球和吊球轻松，但无法精确控制落点 中低磅 20-23磅 击球弹性好，控球较好，但有滞留感（拍面和球接触时） 中磅 23-25磅 拍线和拍子都能发挥其性能，适合业余爱好者 中高磅 25-27磅 控球舒服，但拍面较硬，拉后场可能吃力，击球可能无力 高磅 28磅以上 对球控制力强，但对力量要求高，适合专业运动员 什么是适合自己的磅数？ 低磅：仅业余，平时偶尔打一两次的人。但一般不建议使用低磅。 中低磅：普通业余爱好者，经常打球但没经过专业发力训练。 中磅：有一定水平的业余爱好者，有经过一定的训练，掌握正确的发力方法。 中高磅：高水平业余爱好者，能正确发力。 高磅：专业运动员。业余爱好者亦可尝试，但高磅对拍线会很大地减少拍线的寿命。 4.中杆硬度 什么是中杆硬度？ 击球前的挥拍到球拍击中球，拍杆有一个弯曲到复原的过程。这就关系到球拍的中杆硬度。 中杆硬度以 S 和 F 表示，S表示硬，F表示软，通常分为硬、中硬、适中、稍软、软五个等级。 中杆越软弹性越好，杀球力量越足。中杆越硬，球力量越小，降低击球震动的传递，但挥拍速度更快，适合控制。 如何挑选适合自己的？ 一般入门爱好者建议买软-适中的硬度的拍，更加容易适应。有一定水平的人群更容易驾驭较硬的中杆。 5.球拍材质 球拍材质有哪些？ 球拍类别 特性 全碳素拍 重量较轻，价格较贵，更能使使用者的技术水平发挥出来。 铝碳一体拍 拍框为铝合金，拍杆为碳素纤维，采用“内三通”连接。拍框较重。 铝碳拍 拍框为铝合金，拍杆为碳素纤维，采用“外三通”连接。重量、价格适中。 铝合金拍 拍框铝合金，拍杆为铁管，采用“外三通”连接。 铝铁一体拍 拍框为铝合金，拍杆为铁管，采用“内三通”连接。 铁拍 拍框用铁材，拍杆为铁管，拍体较重，易变形。（超市拍，不推荐） 如何挑选？ 实体店挑选时拍杆和拍框上会分别标有制造材料，而网购页面一般也会标出其材质。 建议购买“全碳”“高碳”“碳”类别的拍。“铁拍”易变形，如果不希望打两次拍就变形的话请勿购买。 参考资料： 买购网","tags":[{"name":"羽毛球","slug":"羽毛球","permalink":"https://adgnn.github.io/tags/羽毛球/"}]},{"title":"小米9安装谷歌相机教程","date":"2019-05-04T10:50:49.556Z","path":"2019/05/04/2019-5-4-小米9安装谷歌相机教程/","text":"前言小米9自带相机虽然有很多功能，但基本照相功能在HDR开启以及暗光模式下的表示却不尽如人意。 谷歌的Pixel系列虽然一直都是单镜头，却凭借着谷歌相机优秀的HDR+算法在手机相机测评得分中名列前茅。 关于HDR+算法，网上有很多介绍它的文章，本篇就不作原理介绍了。我们只需要知道，HDR+算法可以提升画质，改进照片暗部细节，以及极大地提升暗光环境下的照片质量。 因为谷歌相机优秀的算法，许多大神都有做对各大机型适配的移植版本的谷歌相机。 如果你正在使用小米9，并想尝试谷歌相机的话，请跟着本文的步骤操作 如果你使用的是其他型号的手机，请翻到文章最后 1.安装小米9对应移植的谷歌相机 打开Google Camera Port 点击列表的第一个（截至2019-5-4，最新版本是MGC_6_1_021_xcam6_beta3.apk，就可以下载对应的apk文件了 懒人链接：MGC_6_1_021_xcam6_beta3.apk 将APK文件发到小米9上（如果直接使用小米9下载，跳动本步） 安装APK文件 2. 配置你的谷歌相机2.1 下载配置文件 在刚才的Google Camera Port页面点击下载文件右边对应的changelog 打开的页面中找到如下图 随便点击一个（推荐P3XL） 懒人链接：Marian—Xlib2.2s—P3XL—Test4.xml 下载后进入小米9文件管理APP 进入手机分栏 在上方搜索框输入xml 长按刚才下载的Marian---XLib2.2s---P3XL---Test4.xml，更多，复制 选择目录内部存储设备，找到GCam文件夹（如果没有则自己新建一个同名文件夹），打开Configs文件夹。 点击粘贴按钮 2.2 使配置文件生效 打开谷歌相机APP 双击相机界面底部黑色部分 在Choose config下面选择Marian---Xlib2.2s---N6P---Test4.xml，点击RESTORE，自此配置文件已经导入到谷歌相机里了. 导入后我们还要进一步设置，使其符合自己的习惯。参考本人的设置： 3. 使用技巧 长按切换摄像头按钮切换到长焦或广角镜头 长焦：设置里关闭Use 3rd back lens 广角：设置里开启Use 3rd back lens 4. 最后的话对于非小米9手机，只有使用高通处理器的手机才有可能使用谷歌相机。 非小米9高通处理器手机请在这个网址寻找适合自己手机的型号的对应谷歌相机移植版本。","tags":[{"name":"小米9","slug":"小米9","permalink":"https://adgnn.github.io/tags/小米9/"},{"name":"Mi9","slug":"Mi9","permalink":"https://adgnn.github.io/tags/Mi9/"},{"name":"谷歌相机","slug":"谷歌相机","permalink":"https://adgnn.github.io/tags/谷歌相机/"},{"name":"摄影","slug":"摄影","permalink":"https://adgnn.github.io/tags/摄影/"}]},{"title":"计算机组成原理-存储器设计实验","date":"2019-05-03T09:49:01.998Z","path":"2019/05/03/2019-5-3-计算机组成原理-存储器设计实验/","text":"实验目的：掌握灵活运用Verilog HDL语言进行各种描述与建模的技巧和方法；学习在Vivado中使用Memory IP核生成存储器的方法；学习存储器的结构及读写原理，掌握存储器的设计方法。 实验要求：实验vivado内置的IP核生成一个存储器，并写一个顶层模块验证。 验证模块：123456789101112131415161718192021222324252627282930313233343536module ram(out,Write_Addr_swb,sw,Clk_swb,Write_swb);input [32:1]sw;input Write_Addr_swb; //写地址按钮input Clk_swb=0; //时钟引脚input Write_swb=0; //写信号引脚output reg[32:1] out;reg [6:1] Mem_Addr; //6个逻辑开关 当按钮1按下，32位开关中6位是读写存储器的地址reg [32:1] W_Data; //32个逻辑开关 写操作时，当按钮2按下时，32位开关值是写入数据wire [32:1] R_Data;reg Mem_Write; //1个按钮 =1为写操作 =0为读操作reg clka; //时钟RAM_B Data_RAM ( .clka(clka), // input wire clka .wea(Mem_Write), // input wire [0 : 0] wea .addra(Mem_Addr[6:1]), // input wire [5 : 0] addra .dina(W_Data), // input wire [31 : 0] dina .douta(R_Data) // output wire [31 : 0] douta);always @(*) begin clka&lt;=Clk_swb; //时钟 Mem_Write&lt;=Write_swb; //写地址信号 if(Write_Addr_swb) //写地址地址 Mem_Addr&lt;=sw[6:1]; if(!Mem_Write &amp; clka) //读存储器 out&lt;=R_Data; else if(Mem_Write &amp; clka) //写存储器 W_Data&lt;=sw; endendmodule 仿真文件：123456789101112131415161718192021222324252627282930313233343536module ram(out,Write_Addr_swb,sw,Clk_swb,Write_swb);input [32:1]sw;input Write_Addr_swb; //写地址按钮input Clk_swb=0; //时钟引脚input Write_swb=0; //写信号引脚output reg[32:1] out;reg [6:1] Mem_Addr; //6个逻辑开关 当按钮1按下，32位开关中6位是读写存储器的地址reg [32:1] W_Data; //32个逻辑开关 写操作时，当按钮2按下时，32位开关值是写入数据wire [32:1] R_Data;reg Mem_Write; //1个按钮 =1为写操作 =0为读操作reg clka; //时钟RAM_B Data_RAM ( .clka(clka), // input wire clka .wea(Mem_Write), // input wire [0 : 0] wea .addra(Mem_Addr[6:1]), // input wire [5 : 0] addra .dina(W_Data), // input wire [31 : 0] dina .douta(R_Data) // output wire [31 : 0] douta);always @(*) begin clka&lt;=Clk_swb; //时钟 Mem_Write&lt;=Write_swb; //写地址信号 if(Write_Addr_swb) //写地址地址 Mem_Addr&lt;=sw[6:1]; if(!Mem_Write &amp; clka) //读存储器 out&lt;=R_Data; else if(Mem_Write &amp; clka) //写存储器 W_Data&lt;=sw; endendmodule 实验收获：Vivado中IP核的生成和调用方法。更熟练地掌握了仿真调试的方法。在仿真中，使用for语句对16个存储器地址写入，然后读出，很好地验证了预期结果","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://adgnn.github.io/tags/计算机组成原理/"},{"name":"verilog","slug":"verilog","permalink":"https://adgnn.github.io/tags/verilog/"},{"name":"vivado","slug":"vivado","permalink":"https://adgnn.github.io/tags/vivado/"},{"name":"FPGA","slug":"FPGA","permalink":"https://adgnn.github.io/tags/FPGA/"}]},{"title":"计算机组成原理-寄存器堆设计实验","date":"2019-05-03T09:49:01.996Z","path":"2019/05/03/2019-5-3-计算机组成原理-寄存器堆设计实验/","text":"实验目的： 学习使用Verilog HDL语言进行时序电路的设计方法 掌握灵活运用Verilog HDL语言进行各种描述与建模的技巧和方法 学习寄存器堆的数据传送与读写工作原理，掌握寄存器堆的设计方法。 实验要求： 设计一个32*32位的寄存器堆（即含有32个寄存器，每个寄存器32位） 读访问操作：无需时钟同步，只要给出寄存器地址，即可读出寄存器中的数据。 写访问操作：需要时钟同步，所有写入操作的输入信号必须在时钟边沿来临时，已经有效（Write_Reg=1、地址和数据）。 寄存器模块：123456789101112131415161718192021222324252627282930module RegFile(Clk,Clr,Write_Reg,R_Addr_A, R_Addr_B,W_Addr,W_Data,R_Data_A,R_Data_B); input Clk; //时钟信号 input Clr; //清零信号 input Write_Reg; //写控制信号 input [5:1]R_Addr_A; //A端口读寄存器地址 input [5:1]R_Addr_B; //B端口读寄存器地址 input [5:1]W_Addr; //写寄存器地址 input [32:1]W_Data; //写入数据 output [32:1]R_Data_A; //A端口读出数据 output [32:1]R_Data_B; //B端口读出数据 reg [32:1]Reg_Files[31:0]; //寄存器堆 integer i; //遍历 initial for(i=1;i&lt;=32;i=i+1) Reg_Files[i]&lt;=0; always@(posedge Clk or posedge Clr) begin if(Clr)//检测清零 for(i=1;i&lt;=32;i=i+1) Reg_Files[i]&lt;=0; else //检测写控制，高电平则写入寄存器 if(Write_Reg) Reg_Files[W_Addr]&lt;=W_Data; end assign R_Data_A=Reg_Files[R_Addr_A]; assign R_Data_B=Reg_Files[R_Addr_B];endmodule 顶层验证模块：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module registers(sw,button,out); input [32:1] sw; input [6:1] button; output reg[32:1] out=32'hzzzz_zzzz; reg Clk=1'b0; reg Clr=1'b0; reg Write_Reg=1'b0; reg [5:1] R_Addr_A=5'bz; reg [5:1] R_Addr_B=5'bz; reg [5:1] W_Addr=5'bz; reg [32:1] W_Data=32'bz; reg [32:1] Reg_Files[31:0]; wire [32:1] R_Data_A; wire [32:1] R_Data_B; RegFile RF( .Clk(Clk), .Clr(Clr), .Write_Reg(Write_Reg), .R_Addr_A(sw[32:28]), .R_Addr_B(sw[27:23]), .W_Addr(W_Addr), .W_Data(W_Data), .R_Data_A(R_Data_A), .R_Data_B(R_Data_B)); always @(*) begin case(button) 6'b100000: begin W_Addr&lt;=sw[5:1]; end //输入低5位为寄存器地址 6'b010000: begin W_Data&lt;=sw; end //输入寄存器内容 6'b001000: begin Write_Reg&lt;=sw[1]; end//提供Write_Reg信号，=1写操作 6'b000100: begin Clr&lt;=button[3]; end //提供Reset 6'b000010: begin if(sw[1]) out&lt;=R_Data_A; else out&lt;=R_Data_B; end //读A/B端口选择 6'b000000: begin out&lt;=32'bz; Clr&lt;=0; Clk&lt;=0; end 6'b000001: begin Clk&lt;=button[1]; end //提供Clk信号 default: begin out&lt;=32'bz; Clr&lt;=0; Clk&lt;=0; end endcase endendmodule 仿真文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748module registers(sw,button,out); input [32:1] sw; input [6:1] button; output reg[32:1] out=32'hzzzz_zzzz; reg Clk=1'b0; reg Clr=1'b0; reg Write_Reg=1'b0; reg [5:1] R_Addr_A=5'bz; reg [5:1] R_Addr_B=5'bz; reg [5:1] W_Addr=5'bz; reg [32:1] W_Data=32'bz; reg [32:1] Reg_Files[31:0]; wire [32:1] R_Data_A; wire [32:1] R_Data_B; RegFile RF( .Clk(Clk), .Clr(Clr), .Write_Reg(Write_Reg), .R_Addr_A(sw[32:28]), .R_Addr_B(sw[27:23]), .W_Addr(W_Addr), .W_Data(W_Data), .R_Data_A(R_Data_A), .R_Data_B(R_Data_B)); always @(*) begin case(button) 6'b100000: begin W_Addr&lt;=sw[5:1]; end //输入低5位为寄存器地址 6'b010000: begin W_Data&lt;=sw; end //输入寄存器内容 6'b001000: begin Write_Reg&lt;=sw[1]; end//提供Write_Reg信号，=1写操作 6'b000100: begin Clr&lt;=button[3]; end //提供Reset 6'b000010: begin if(sw[1]) out&lt;=R_Data_A; else out&lt;=R_Data_B; end //读A/B端口选择 6'b000000: begin out&lt;=32'bz; Clr&lt;=0; Clk&lt;=0; end 6'b000001: begin Clk&lt;=button[1]; end //提供Clk信号 default: begin out&lt;=32'bz; Clr&lt;=0; Clk&lt;=0; end endcase endendmodule 实验收获：寄存器堆设计和之前的ALU设计有一定的相似之处，如都是顶层+本体的设计方法，顶层控制着外部的输入输出，并将值传递到本体模块进行具体计算。 具体代码实现过程中，利用always语句块和assign语句来区分时序和非时序逻辑电路（写和读）。仿真过程遇到了点问题，最后一步本意为输出B读端口（ffff_ffff），结果输出为0，但上板后没有问题。","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://adgnn.github.io/tags/计算机组成原理/"},{"name":"verilog","slug":"verilog","permalink":"https://adgnn.github.io/tags/verilog/"},{"name":"vivado","slug":"vivado","permalink":"https://adgnn.github.io/tags/vivado/"},{"name":"FPGA","slug":"FPGA","permalink":"https://adgnn.github.io/tags/FPGA/"}]},{"title":"计算机组成原理-多功能ALU设计","date":"2019-05-03T09:49:01.994Z","path":"2019/05/03/2019-5-3-计算机组成原理-多功能ALU设计/","text":"实验目的： 学习多功能ALU的工作原理，掌握运算器的设计方法。 掌握运用Verilog HDL语言进行行为描述与建模的技巧和方法。 实验要求： 设计一个具有8种运算功能的32位ALU，并能够产生运算结果的标志：结果为零标志ZF，溢出标志OF。 编写顶层模块，用于验证模块的正确性。 ALU模块：12345678910111213141516171819202122232425262728293031module ALU1(A,B,F,ALU_OP,OF,ZF); input [32:1] A; input [32:1] B; input [4:1] ALU_OP; output reg [32:1] F; output reg ZF,OF; reg C; always @(*) begin case(ALU_OP) 4'b0: begin F&lt;=A&amp;B; OF&lt;=0; end 4'b1: begin F&lt;=A|B; OF&lt;=0; end 4'b10:begin F&lt;=A^B; OF&lt;=0; end 4'b11:begin F&lt;=~(A|B); OF&lt;=0; end 4'b100:begin &#123;C,F&#125;&lt;=A+B; OF&lt;=C; end 4'b101:begin &#123;C,F&#125;&lt;=A-B; OF&lt;=C; end 4'b110:begin if(A&lt;B) F&lt;=1; else F&lt;=0; end 4'b111:begin F&lt;=B&lt;&lt;A; OF&lt;=1; end default:begin F&lt;=32'hzzzz_zzzz; OF&lt;=1'bz; end endcase if(F==0) ZF&lt;=1; else ZF&lt;=0; endendmodule 顶层验证模块：12345678910111213141516171819202122232425262728293031module ALU1(A,B,F,ALU_OP,OF,ZF); input [32:1] A; input [32:1] B; input [4:1] ALU_OP; output reg [32:1] F; output reg ZF,OF; reg C; always @(*) begin case(ALU_OP) 4'b0: begin F&lt;=A&amp;B; OF&lt;=0; end 4'b1: begin F&lt;=A|B; OF&lt;=0; end 4'b10:begin F&lt;=A^B; OF&lt;=0; end 4'b11:begin F&lt;=~(A|B); OF&lt;=0; end 4'b100:begin &#123;C,F&#125;&lt;=A+B; OF&lt;=C; end 4'b101:begin &#123;C,F&#125;&lt;=A-B; OF&lt;=C; end 4'b110:begin if(A&lt;B) F&lt;=1; else F&lt;=0; end 4'b111:begin F&lt;=B&lt;&lt;A; OF&lt;=1; end default:begin F&lt;=32'hzzzz_zzzz; OF&lt;=1'bz; end endcase if(F==0) ZF&lt;=1; else ZF&lt;=0; endendmodule 仿真文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283`timescale 1ns / 1psmodule test; reg [32:1] sw; reg [6:1] button; wire [32:1] out; alu uut( .sw(sw), .button(button), .out(out) ); initial begin sw = 0; button = 0; #100; //input A sw = 32'h1234_5678; button = 6'b100000; #50; //input B sw = 32'h1111_2222; button = 6'b010000; #50; //and sw[4:1] = 4'h0; button = 6'b001000; #50; button = 6'b0; #50; //or sw[4:1] = 4'h1; button = 6'b001000; #50; button = 6'b0; #50; //xor sw[4:1] = 4'h2; button = 6'b001000; #50; button = 6'b0; #50; //nor sw[4:1] = 4'h3; button = 6'b001000; #50; button = 6'b0; #50; //add sw[4:1] = 4'h4; button = 6'b001000; #50; button = 6'b0; #50; //sub sw[4:1] = 4'h5; button=6'b001000; #50; button = 6'b0; #50; //slt sw[4:1] = 4'h6; button = 6'b001000; #50; button = 6'b0; #50; //sll sw[4:1] = 4'h7; button = 6'b001000; #50; button = 6'b0; #50; endendmodule 实验收获：实验过程中，我发现自己对Verilog HDL语言的熟悉程度不够。特别是对阻塞赋值与非阻塞赋值的思想没有理解透彻，导致程序在调试过程中不断出现BUG，难以表达应有的逻辑思想。编程没有充分体现电路本身的特征，仍然是用C语言等高级程序设计语言的思想来编程。 总体来说，本实验较为基础，不困难。","tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://adgnn.github.io/tags/计算机组成原理/"},{"name":"verilog","slug":"verilog","permalink":"https://adgnn.github.io/tags/verilog/"},{"name":"vivado","slug":"vivado","permalink":"https://adgnn.github.io/tags/vivado/"},{"name":"FPGA","slug":"FPGA","permalink":"https://adgnn.github.io/tags/FPGA/"}]}]